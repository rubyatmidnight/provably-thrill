
Source: https://intercom.help/thrill/en/collections/14974650-provably-fair


Provably Fair - Introduction
Updated over 3 months ago
Table of contents
Building Trust and Fair Play in Our Games
In online gaming, fairness must be transparent and verifiable. The concept of Provably Fair addresses this by guaranteeing that:

Every game result is genuinely random

The result cannot be influenced by the operator

All participants have equal chances of winning

Each outcome is unpredictable until revealed, ensuring complete impartiality

How We Implement Provably Fair
Our system combines a commitment scheme with cryptographic hashing to secure integrity.

 

1. Commitment Scheme
In cryptography, a commitment scheme is an arrangement that cannot be changed.

For Provably Fair, we use a two-party key:

A server seed (on the operator side)

A client seed (on the player side)

Before a game begins:

The server seed is generated

When combined with the client seed, it defines the final outcome in an immutable way

âœ… Players can later verify this value to confirm that no alterations occurred after their wager.

 

2. HMACSHA-512 Hashing
This cryptographic algorithm:

Produces a secure, tamper-proof hash of the commitment data

Prevents manipulation

Ensures the original input can be verified without being exposed in advance

Conclusion
Together, these methods create a transparent and verifiable system where:

Results remain both unpredictable and provable

Players can have confidence that every outcome is fair



page 2:

Provably Fair - Commitment Schemes
Updated over 3 months ago
Table of contents
What is a Commitment Scheme?
A commitment scheme is a cryptographic method that enables both the platform and the player to lock in a secret value while keeping it hidden. It ensures:

Transparency: The hidden value is later revealed to prove nothing changed

Fairness: Neither party can manipulate the outcome after the commitment is made

Auditability: The process is independently verifiable

A commitment scheme works in two phases:
â€‹1. Commit
â€‹2. Reveal

 

 

Key Terminology
Term

Description

Server Seed

A random 64-character string generated by the system. Its SHA-512 hash is visible to the player during gameplay. 
ğŸ”’ Anti-cheating: Hash hides original seed.
ğŸ”’ Anti-manipulation: Collision-resistant.

Client Seed

A player-controlled value. Random by default, but editable by the player. Gives players influence over randomness.

Nonce

Short for "number once." Increments with every bet using the same server + client seed combo. Ensures uniqueness of each round.

Cursor

A sub-nonce, used to generate multiple random numbers in a single round. Starts at 0 and increases as needed.

Random Bytes

The underlying data unit (8 binary digits) used to produce randomness.

Integer

A whole number (no decimal).

Floating Point Number

A number between 0 (inclusive) and 1 (exclusive), with a fractional component.

 
 

Commit Phase
 

This phase occurs during every bet placed. It locks in the values used to generate the game result:

Inputs:
Active Client Seed â€“ Player's input (not hashed)

Active Server Seed (Unhashed) â€“ Secret value generated by the server (only hash is shown during play)

Nonce â€“ Increments per bet (starting at 1 for rotated seeds)

Cursor â€“ Starts at 0; increases if more than one random number is needed

 

Randomness Generation:
 

RandomBytes = HMACSHA512( Active_Server_Seed, Active_Client_Seed:Nonce:Cursor )
 

These random bytes are then used to generate either integers or floating point numbers.

 

ğŸ” The player only sees the hashed server seed until the reveal phase (to prevent outcome prediction).

 

 

Reveal Phase
In this stage, the unhashed server seed is revealed. With all components now available:

Server Seed (unhashed)

Client Seed

Nonce

Players can verify the outcome was fairly generated.

When players rotate their seed pair, the old server seed is revealed and invalidated for future use.

âœ… This allows for independent verification by the player, operator, or third-party auditors.



page 3: 


Provably Fair - Implementation
Updated over 3 months ago
Table of contents
Generating Random Numbers for Instant Games
 

Overview
The process for generating random numbers in instant games involves two main steps:

Generate a 512-bit (64-byte) random array using:

RandomBytes = HMACSHA512(Active_Server_Seed, Active_Client_Seed:Nonce:Cursor)
Extract the needed valueâ€”either an integer or a floating point numberâ€”from the generated bytes.

ğŸ“Œ Note: This process differs from how random numbers are generated for scheduled games.

 

 

Generating Random Bytes
The core function is generateRandomBytes(). Here is the pseudocode:

byte[] byteGenerator(serverSeed, clientSeed, nonce, cursor) {
    // 1. Create an HMAC512 hasher with server seed as the key
    let hasher = HMAC512(serverSeed)

    // 2. Format the message as: clientSeed:nonce:cursor
    let message = clientSeed:nonce:cursor

    // 3. Hash the message
    let randomBytes = hasher.Hash(message)

    // 4. Increment the cursor
    cursor = cursor + 1

    // 5. Return the random bytes
    return randomBytes
}
These randomBytes are then passed into either:

generateDouble() â†’ for floating point numbers

NextPositiveInt32() â†’ for integers

 

 

Generating Floating Point Numbers
Floating Point Structure (IEEE 754 - 64-bit double):
1 bit: Sign (positive/negative)

11 bits: Exponent

52 bits: Mantissa/Fraction

The mantissa controls the precision for values between 0 and 1.

Algorithm
Generate 7 random bytes

Combine into a 56-bit number

Mask to keep the lowest 52 bits

Divide by 2^52 â†’ Gives a uniform value between 0 (inclusive) and 1 (exclusive)

Pseudocode:
double generateDouble() {
    bytes = generateRandomBytes(7)

    bits = 0
    for each byte in bytes:
        bits = (bits << 8) OR byte

    masked = bits AND (2^52 - 1)
    randomDouble = masked / 2^52

    return randomDouble
}
âœ… This ensures maximum precision and equal probability for all outcomes in the range [0, 1).

 

 

Generating Integers
Unlike some operators who derive integers from floats (which can cause bias), this method directly generates uniform integers, ensuring fairness and accuracy.

Why This Matters:
Mapping floats to integers (e.g., floor(float * N)) introduces rounding issues

This method uses rejection sampling to avoid bias

How It Works:
Draw a 32-bit random unsigned integer (value)

Define a rejection limit:

limit = MAX_UINT32 - (MAX_UINT32 % maxExclusive)
If value < limit, use:

result = value % maxExclusive
If not, discard and draw new bytes

ğŸ›‘ Rejection Sampling ensures perfectly uniform results in [0, maxExclusive)

 

 

Pseudocode:

Page 4:


Provably Fair - Game Event
Updated this week
Table of contents
Instant Game Implementation
Overview
This document builds upon previously explained RNG (Random Number Generation) principles to show how individual game results are produced using random integers and floating-point numbers.

 

Game-by-Game Breakdown
 

â˜„ï¸ Plinko 
In Plinko, the player chooses the number of rows (between 8 and 16) and a risk profile. The number of rows determines the number of buckets: X rows produce X+1 buckets. 

 

Each possible path the ball can take corresponds to a unique trajectory, and there are 2^X total trajectories.


The random number generator (RNG) selects an integer between 0 and 2^X â€“ 1. This integer represents a trajectory. To find the bucket:

Convert the integer to binary.

Count the number of 1s in the binary representation.

That count is the bucket index.

The risk profile does not affect which bucket is chosenâ€”it only determines the payout for that bucket.
Example (8 rows):
â€‹

Total trajectories = 2^8 = 256

RNG generates a number between 0 and 255

RNG = 0 â†’ binary 00000000 â†’ sum of 1s = 0 â†’ bucket index = 0

RNG = 200 â†’ binary 11001000 â†’ sum of 1s = 3 â†’ bucket index = 3

RNG = 255 â†’ binary 11111111 â†’ sum of 1s = 8 â†’ bucket index = 8

Pseudocode:
generatePlinkoResult(rows, riskProfile)
{
    // Generate a number between 0 and 2 ^ Rows
    let bucketIndex = generateInteger(2 ^ Rows)
 
    // Get the payout for the given bucket index.  
    let payout = getPayout(bucketIndex, riskProfile)
    
    return payout
}
 

 

 

ğŸ² Dice
Goal: Produce a number between 0.00 and 100.00 with two decimal places

Approach:

Generate a random integer between 0 (inclusive) and 10001 (exclusive)

Divide the result by 100

Pseudocode:
generateDiceResult() {
    let randomInteger = generateInteger(10001)
    let result = randomInteger / 100
    return result
}
 

 

ğŸ’£ Mines
Goal: Reveal gems while avoiding mines

Approach:

Use RNG to randomly assign numberOfMines positions on a board

The rest of the tiles are considered "gems"

Pseudocode:
generateMinesBoard(edgeSize, numberOfMines) {
    let totalTiles = edgeSize * edgeSize
    let minesPositions = []

    while minesPositions.Count < numberOfMines:
        let currentPosition = generateInteger(totalTiles)
        if currentPosition not in minesPositions:
            minesPositions.add(currentPosition)

    let board = []
    for index in 0 to totalTiles - 1:
        if index in minesPositions:
            board.add("mine")
        else:
            board.add("gem")

    return board
}
 

 

ğŸ“ˆ Limbo
Goal: Generate a multiplier > 1 (user wins if the rolled multiplier exceeds their guess)

Approach:

Generate a random float

Apply a hyperbolic curve to determine payout

Truncate to two decimal places

Formula Explanation:
houseEdge = 2.0 - rtp (e.g., if RTP is 0.99, house edge is 1.01)

multiplier = 1.0 / ((1.0 - randomFloat) * houseEdge)

Pseudocode:


generateLimboMultiplier(rtp) {
    let multiplierDecimalPlaces = 2
    let randomFloat = generateDouble()
    let houseEdge = 2.0 - rtp
    let multiplier = 1.0 / ((1.0 - randomFloat) * houseEdge)
    let roundedMultiplier = truncate(multiplier, multiplierDecimalPlaces)
    return roundedMultiplier
}
 

 

ğŸ± Keno
Goal: Randomly draw a set of unique numbers from a board (usually 1â€“40)

Approach:

Randomly select numbers, ensuring they:

Are not zero

Are not duplicates

Pseudocode:


generateKenoDraw(boardSize, drawCount) {
    let numbersDrawn = []

    while numbersDrawn.Count < drawCount:
        let currentDraw = generateInteger(boardSize + 1)
        if currentDraw == 0 or currentDraw in numbersDrawn:
            continue
        numbersDrawn.add(currentDraw)

    return numbersDrawn
}
 

 

ğŸƒ Blackjack

 

Blackjack is a card game, in which the RNG is used to draw a set of random cards. For a single seat game, four cards are initially drawn in the following order: Player, Dealer, Player, Dealer. Other cards can be drawn according to the subsequent player's actions.

 

At the beginning of every Blackjack round the nonce of the Provably Fair Seed is incremented. For each card dealt (initial or as a result of a player action - split, hit, double) a random number is generated between 0 and 51 and the cursor is increased. The number generated indicates the index of a card in an ordered deck (from Ace to King, suit order is: Hearts, Diamonds, Clubs, Spades). Dealer cards are drawn the same way after user actions had concluded. For reference, 0 is Ace of Hearts, 51 is King of Spades.


Spades.Pseudo code:
â€‹

dealCard() 
{
// Generate a random number from 0 .. 51
// Every time generateInteger is called, the cursor is incremented.        let cardIndex = generateInteger(52)
// This gets the card object from the index of the card.   
return Card.FromIndex(cardIndex); }
 